<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¿»è¨³ã‚¨ãƒ‡ã‚£ã‚¿ - DPH Translation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header {
            background-color: #2c3e50;
            color: white;
            padding: 20px 30px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2980b9;
        }

        .btn-success {
            background-color: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background-color: #229954;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .content {
            padding: 30px;
        }

        .stats {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            gap: 30px;
        }

        .stat-item {
            font-size: 14px;
        }

        .stat-item strong {
            color: #2c3e50;
        }

        .entry {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .entry-header {
            background-color: #34495e;
            color: white;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .entry-id {
            font-weight: bold;
        }

        .entry-kind {
            background-color: #3498db;
            padding: 3px 10px;
            border-radius: 3px;
            font-size: 12px;
            text-transform: uppercase;
        }

        .entry-body {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            padding: 20px;
        }

        .entry-section {
            display: flex;
            flex-direction: column;
        }

        .entry-section h3 {
            font-size: 14px;
            margin-bottom: 10px;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .entry-section .text-display {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.6;
            min-height: 100px;
            overflow-y: auto;
        }

        .entry-section textarea {
            border: 2px solid #3498db;
            border-radius: 4px;
            padding: 15px;
            font-family: inherit;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            min-height: 100px;
            overflow-y: auto;
            transition: border-color 0.3s;
        }

        .entry-section textarea:focus {
            outline: none;
            border-color: #2980b9;
        }

        .entry-section textarea.modified {
            border-color: #27ae60;
            background-color: #f0fff4;
        }

        .modified-indicator {
            display: inline-block;
            background-color: #27ae60;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            margin-left: 10px;
        }

        .diff-highlight {
            background-color: #d4edda;
            color: #155724;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .diff-highlight-removed {
            background-color: #f8d7da;
            color: #721c24;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .comment-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background-color: #ffc107;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 2px;
            vertical-align: middle;
            transition: background-color 0.2s;
        }

        .comment-icon:hover {
            background-color: #ff9800;
        }

        .add-comment-btn {
            position: absolute;
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .add-comment-btn:hover {
            background-color: #1976D2;
        }

        .comment-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            border: 2px solid #3498db;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            z-index: 2000;
            min-width: 400px;
        }

        .comment-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0,0,0,0.5);
            z-index: 1999;
        }

        .comment-dialog h3 {
            margin-top: 0;
            color: #2c3e50;
        }

        .comment-dialog textarea {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
        }

        .comment-dialog-buttons {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .comment-dialog-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }

        .comment-dialog-buttons .save-btn {
            background-color: #27ae60;
            color: white;
        }

        .comment-dialog-buttons .save-btn:hover {
            background-color: #229954;
        }

        .comment-dialog-buttons .delete-btn {
            background-color: #e74c3c;
            color: white;
        }

        .comment-dialog-buttons .delete-btn:hover {
            background-color: #c0392b;
        }

        .comment-dialog-buttons .cancel-btn {
            background-color: #95a5a6;
            color: white;
        }

        .comment-dialog-buttons .cancel-btn:hover {
            background-color: #7f8c8d;
        }

        .no-data {
            text-align: center;
            padding: 60px;
            color: #7f8c8d;
        }

        .no-data h2 {
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #3498db;
        }

        select {
            padding: 10px 15px;
            border: 2px solid #3498db;
            border-radius: 5px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
            min-width: 250px;
        }

        select:focus {
            outline: none;
            border-color: #2980b9;
        }

        @media (max-width: 1200px) {
            .entry-body {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ç¿»è¨³ã‚¨ãƒ‡ã‚£ã‚¿</h1>
            <div class="controls">
                <select id="folderSelect">
                    <option value="">ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ...</option>
                </select>
                <select id="fileSelect" disabled>
                    <option value="">CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ...</option>
                </select>
                <button id="loadBtn" class="btn btn-primary" disabled>èª­ã¿è¾¼ã‚€</button>
                <button id="exportBtn" class="btn btn-success" disabled>ä¿®æ­£æ¸ˆã¿CSVã‚’ä¿å­˜</button>
            </div>
        </div>
        <div class="content">
            <div class="stats" id="stats" style="display: none;">
                <div class="stat-item">
                    <strong>ç·ã‚¨ãƒ³ãƒˆãƒªæ•°:</strong> <span id="totalEntries">0</span>
                </div>
                <div class="stat-item">
                    <strong>ä¿®æ­£æ¸ˆã¿:</strong> <span id="modifiedEntries">0</span>
                </div>
                <div class="stat-item">
                    <strong>ãƒ•ã‚¡ã‚¤ãƒ«å:</strong> <span id="fileName">-</span>
                </div>
            </div>
            <div id="entriesContainer">
                <div class="no-data">
                    <h2>CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„</h2>
                    <p>1. ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ<br>2. CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ<br>3. ã€Œèª­ã¿è¾¼ã‚€ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        let csvData = [];
        let originalData = [];
        let llmTranslations = [];
        let currentFileName = '';
        let currentFolder = '';
        let commentsData = {}; // { entry_id: [{offset, length, comment, author}] }
        const commentAuthors = ['å°å·', 'å¾Œè—¤', 'åŸ']; // ã‚³ãƒ¡ãƒ³ãƒˆä½œæˆè€…ã®é¸æŠè‚¢

        const folderSelect = document.getElementById('folderSelect');
        const fileSelect = document.getElementById('fileSelect');
        const loadBtn = document.getElementById('loadBtn');
        const exportBtn = document.getElementById('exportBtn');
        const entriesContainer = document.getElementById('entriesContainer');
        const statsDiv = document.getElementById('stats');
        const totalEntriesSpan = document.getElementById('totalEntries');
        const modifiedEntriesSpan = document.getElementById('modifiedEntries');
        const fileNameSpan = document.getElementById('fileName');

        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒ•ã‚©ãƒ«ãƒ€ä¸€è¦§ã‚’å–å¾—
        window.addEventListener('load', loadFolderList);

        folderSelect.addEventListener('change', function() {
            if (folderSelect.value) {
                currentFolder = folderSelect.value;
                loadCSVFileList(currentFolder);
            } else {
                fileSelect.disabled = true;
                fileSelect.innerHTML = '<option value="">CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ...</option>';
                loadBtn.disabled = true;
            }
        });

        fileSelect.addEventListener('change', function() {
            loadBtn.disabled = !fileSelect.value;
        });

        loadBtn.addEventListener('click', loadSelectedCSV);
        exportBtn.addEventListener('click', exportCSV);

        async function loadFolderList() {
            try {
                const response = await fetch('/api/folders');
                const data = await response.json();

                if (data.folders && data.folders.length > 0) {
                    data.folders.forEach(foldername => {
                        const option = document.createElement('option');
                        option.value = foldername;
                        option.textContent = foldername;
                        folderSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.textContent = 'ãƒ•ã‚©ãƒ«ãƒ€ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
                    option.disabled = true;
                    folderSelect.appendChild(option);
                }
            } catch (error) {
                console.error('ãƒ•ã‚©ãƒ«ãƒ€ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                entriesContainer.innerHTML = `
                    <div class="no-data">
                        <h2>ã‚¨ãƒ©ãƒ¼</h2>
                        <p>ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ã€‚</p>
                        <p>ã‚¿ãƒ¼ãƒŸãƒŠãƒ«ã§ <code>python3 server.py</code> ã‚’å®Ÿè¡Œã—ã¦ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¦ãã ã•ã„ã€‚</p>
                    </div>
                `;
            }
        }

        async function loadCSVFileList(folder) {
            fileSelect.innerHTML = '<option value="">CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ...</option>';
            fileSelect.disabled = true;
            loadBtn.disabled = true;

            try {
                const response = await fetch(`/api/csv-files/${folder}`);
                const data = await response.json();

                if (data.files && data.files.length > 0) {
                    data.files.forEach(fileInfo => {
                        const option = document.createElement('option');
                        // is_originalãƒ•ãƒ©ã‚°ã«åŸºã¥ã„ã¦ãƒ‘ã‚¹ã‚’è¨­å®š
                        option.value = fileInfo.is_original ? `original/${fileInfo.name}` : fileInfo.name;
                        option.textContent = fileInfo.display_name;
                        fileSelect.appendChild(option);
                    });
                    fileSelect.disabled = false;
                } else {
                    const option = document.createElement('option');
                    option.textContent = 'CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
                    option.disabled = true;
                    fileSelect.appendChild(option);
                }
            } catch (error) {
                console.error('CSVãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
            }
        }

        async function loadSelectedCSV() {
            const filename = fileSelect.value;
            if (!filename || !currentFolder) return;

            const fullPath = `${currentFolder}/${filename}`;
            currentFileName = fullPath;
            fileNameSpan.textContent = fullPath;

            entriesContainer.innerHTML = '<div class="loading">èª­ã¿è¾¼ã¿ä¸­...</div>';

            try {
                const response = await fetch(`/api/csv-content/${fullPath}`);
                const data = await response.json();

                // LLMç¿»è¨³åŸæ–‡ã‚’ãƒ‘ãƒ¼ã‚¹
                let hasOriginal = false;
                if (data.original_content) {
                    parseLLMTranslations(data.original_content);
                    hasOriginal = true;
                } else {
                    llmTranslations = {};
                }

                // ç·¨é›†ç”¨CSVã‚’ãƒ‘ãƒ¼ã‚¹
                // originalãƒ•ã‚©ãƒ«ãƒ€ã®ã¿å­˜åœ¨ã™ã‚‹å ´åˆã€ãã‚Œã‚’ç·¨é›†ç”¨ã¨ã—ã¦ã‚‚ä½¿ç”¨
                if (!data.csv_content && hasOriginal) {
                    parseCSV(data.original_content);
                } else {
                    parseCSV(data.csv_content);
                }

                // ã‚³ãƒ¡ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
                await loadComments(fullPath);

                // å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                renderEntries();
            } catch (error) {
                console.error('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                entriesContainer.innerHTML = `
                    <div class="no-data">
                        <h2>ã‚¨ãƒ©ãƒ¼</h2>
                        <p>CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>
                    </div>
                `;
            }
        }

        async function loadComments(filePath) {
            try {
                const response = await fetch(`/api/comments/${filePath}`);
                const data = await response.json();
                commentsData = data || {};
            } catch (error) {
                console.error('ã‚³ãƒ¡ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
                commentsData = {};
            }
        }

        async function saveComments() {
            try {
                const response = await fetch('/api/save-comments', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        filePath: currentFileName,
                        commentsData: commentsData
                    })
                });

                const result = await response.json();
                if (!result.success) {
                    console.error('ã‚³ãƒ¡ãƒ³ãƒˆã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ:', result.error);
                }
            } catch (error) {
                console.error('ã‚³ãƒ¡ãƒ³ãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n');
            const headers = parseCSVLine(lines[0]);

            csvData = [];

            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;

                const values = parseCSVLine(lines[i]);
                if (values.length >= 4) {
                    csvData.push({
                        id: values[0],
                        kind: values[1],
                        text_en: values[2],
                        text_ja: values[3],
                        modified: false
                    });
                }
            }

            originalData = JSON.parse(JSON.stringify(csvData));
        }

        function parseLLMTranslations(csvText) {
            const lines = csvText.split('\n');
            llmTranslations = {};

            for (let i = 1; i < lines.length; i++) {
                if (lines[i].trim() === '') continue;

                const values = parseCSVLine(lines[i]);
                if (values.length >= 4) {
                    // IDã‚’ã‚­ãƒ¼ã«ã—ã¦æ—¥æœ¬èªè¨³ã‚’æ ¼ç´
                    llmTranslations[values[0]] = values[3];
                }
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"') {
                    if (inQuotes && nextChar === '"') {
                        current += '"';
                        i++;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);

            return result;
        }

        function renderEntries() {
            entriesContainer.innerHTML = '';

            csvData.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'entry';

                const kindColors = {
                    'title': '#e74c3c',
                    'abstract': '#9b59b6',
                    'keyword': '#f39c12',
                    'body': '#3498db'
                };

                const kindColor = kindColors[entry.kind] || '#95a5a6';

                const llmTranslation = llmTranslations[entry.id] || '';

                // å·®åˆ†ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã™ã‚‹HTMLã‚’ç”Ÿæˆ
                let highlightedEditedText = llmTranslation ? generateHighlightedDiff(llmTranslation, entry.text_ja, 'added') : escapeHtml(entry.text_ja);
                const highlightedLLMText = llmTranslation ? generateHighlightedDiff(llmTranslation, entry.text_ja, 'removed') : escapeHtml(llmTranslation);

                // ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã‚’æŒ¿å…¥
                highlightedEditedText = insertCommentIcons(highlightedEditedText, entry.id, entry.text_ja);

                entryDiv.innerHTML = `
                    <div class="entry-header">
                        <div class="entry-id">ID: ${entry.id}</div>
                        <div class="entry-kind" style="background-color: ${kindColor};">${entry.kind}</div>
                    </div>
                    <div class="entry-body">
                        <div class="entry-section">
                            <h3>è‹±èªåŸæ–‡</h3>
                            <div class="text-display">${escapeHtml(entry.text_en)}</div>
                        </div>
                        <div class="entry-section">
                            <h3>LLMç¿»è¨³ï¼ˆå‚è€ƒï¼‰</h3>
                            <div class="text-display llm-translation" style="background-color: #fffbf0; border-color: #ffc107;">${highlightedLLMText}</div>
                        </div>
                        <div class="entry-section">
                            <h3>
                                æ—¥æœ¬èªè¨³ï¼ˆç·¨é›†å¯ï¼‰
                                ${entry.modified ? '<span class="modified-indicator">ä¿®æ­£æ¸ˆã¿</span>' : ''}
                            </h3>
                            <textarea data-index="${index}" class="${entry.modified ? 'modified' : ''}" style="display: none;">${escapeHtml(entry.text_ja)}</textarea>
                            <div class="text-display editable-display" data-index="${index}" contenteditable="true" style="background-color: white; cursor: text;">${highlightedEditedText}</div>
                        </div>
                    </div>
                `;

                entriesContainer.appendChild(entryDiv);

                const textarea = entryDiv.querySelector('textarea');
                const textDisplays = entryDiv.querySelectorAll('.text-display');
                const editableDisplay = entryDiv.querySelector('.editable-display');

                // 3ã¤ã®åˆ—ã®æœ€å¤§é«˜ã•ã‚’å–å¾—
                let maxHeight = 0;
                textDisplays.forEach(display => {
                    maxHeight = Math.max(maxHeight, display.scrollHeight);
                });

                // ã™ã¹ã¦ã®åˆ—ã‚’æœ€å¤§é«˜ã•ã«æƒãˆã‚‹
                textDisplays.forEach(display => {
                    display.style.height = maxHeight + 'px';
                });

                // ç·¨é›†å¯èƒ½ãªdivã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
                if (editableDisplay) {
                    // ãƒ†ã‚­ã‚¹ãƒˆé¸æŠæ™‚ã®ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ãƒœã‚¿ãƒ³è¡¨ç¤º
                    editableDisplay.addEventListener('mouseup', function(e) {
                        handleTextSelection(e, entry.id, editableDisplay);
                    });

                    // ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                    editableDisplay.addEventListener('click', function(e) {
                        if (e.target.classList.contains('comment-icon')) {
                            const commentIndex = parseInt(e.target.dataset.commentIndex);
                            showCommentDialog(entry.id, commentIndex);
                            e.stopPropagation();
                        }
                    });

                    editableDisplay.addEventListener('input', function() {
                        const plainText = this.innerText;
                        textarea.value = plainText;
                        handleTextChange(index, plainText);

                        // å†åº¦å·®åˆ†ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆæ—¥æœ¬èªè¨³ã¨LLMç¿»è¨³ã®ä¸¡æ–¹ï¼‰
                        const llmText = llmTranslations[csvData[index].id] || '';
                        if (llmText) {
                            let newHighlightedText = generateHighlightedDiff(llmText, plainText, 'added');
                            const newHighlightedLLMText = generateHighlightedDiff(llmText, plainText, 'removed');

                            // ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã‚’æŒ¿å…¥
                            newHighlightedText = insertCommentIcons(newHighlightedText, csvData[index].id, plainText);

                            // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’ä¿å­˜
                            const selection = window.getSelection();
                            const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
                            const offset = range ? range.startOffset : 0;

                            // ç·¨é›†å¯èƒ½ãªæ—¥æœ¬èªè¨³ã‚’æ›´æ–°
                            this.innerHTML = newHighlightedText;

                            // LLMç¿»è¨³ã‚‚æ›´æ–°
                            const llmDisplay = entryDiv.querySelector('.llm-translation');
                            if (llmDisplay) {
                                llmDisplay.innerHTML = newHighlightedLLMText;
                            }

                            // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã‚’å¾©å…ƒï¼ˆç°¡æ˜“ç‰ˆï¼‰
                            try {
                                const textNode = this.firstChild;
                                if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                                    const newRange = document.createRange();
                                    newRange.setStart(textNode, Math.min(offset, textNode.length));
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                }
                            } catch (e) {
                                // ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®å¾©å…ƒã«å¤±æ•—ã—ãŸå ´åˆã¯ç„¡è¦–
                            }
                        }
                    });
                }
            });

            updateStats();
            exportBtn.disabled = false;
            statsDiv.style.display = 'flex';
        }

        function generateHighlightedDiff(text1, text2, highlightType) {
            // æ–‡å­—å˜ä½ã§å·®åˆ†ã‚’è¨ˆç®—
            const diff = computeDiff(text1, text2);
            let html = '';

            diff.forEach(part => {
                if (highlightType === 'added') {
                    // æ—¥æœ¬èªè¨³ï¼ˆç·¨é›†å¯ï¼‰ç”¨ï¼šè¿½åŠ ã•ã‚ŒãŸéƒ¨åˆ†ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    if (part.type === 'added') {
                        html += `<span class="diff-highlight">${escapeHtml(part.value)}</span>`;
                    } else if (part.type === 'unchanged') {
                        html += escapeHtml(part.value);
                    }
                    // removedã¯è¡¨ç¤ºã—ãªã„
                } else if (highlightType === 'removed') {
                    // LLMç¿»è¨³ç”¨ï¼šå‰Šé™¤ã•ã‚ŒãŸéƒ¨åˆ†ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    if (part.type === 'removed') {
                        html += `<span class="diff-highlight-removed">${escapeHtml(part.value)}</span>`;
                    } else if (part.type === 'unchanged') {
                        html += escapeHtml(part.value);
                    }
                    // addedã¯è¡¨ç¤ºã—ãªã„
                }
            });

            // htmlãŒç©ºã®å ´åˆ
            if (!html) {
                return highlightType === 'added' ? escapeHtml(text2) : escapeHtml(text1);
            }
            return html;
        }

        function computeDiff(text1, text2) {
            // ã‚·ãƒ³ãƒ—ãƒ«ãªæ–‡å­—å˜ä½ã®å·®åˆ†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
            const len1 = text1.length;
            const len2 = text2.length;
            const matrix = [];

            // DPè¡Œåˆ—ã‚’åˆæœŸåŒ–
            for (let i = 0; i <= len1; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= len2; j++) {
                matrix[0][j] = j;
            }

            // DPè¡Œåˆ—ã‚’åŸ‹ã‚ã‚‹
            for (let i = 1; i <= len1; i++) {
                for (let j = 1; j <= len2; j++) {
                    if (text1[i - 1] === text2[j - 1]) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j] + 1,    // å‰Šé™¤
                            matrix[i][j - 1] + 1,    // æŒ¿å…¥
                            matrix[i - 1][j - 1] + 1 // ç½®æ›
                        );
                    }
                }
            }

            // ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ã—ã¦å·®åˆ†ã‚’æ§‹ç¯‰
            const result = [];
            let i = len1, j = len2;

            while (i > 0 || j > 0) {
                if (i > 0 && j > 0 && text1[i - 1] === text2[j - 1]) {
                    result.unshift({ type: 'unchanged', value: text1[i - 1] });
                    i--;
                    j--;
                } else if (j > 0 && (i === 0 || matrix[i][j - 1] <= matrix[i - 1][j])) {
                    // è¿½åŠ  (insertionã‚’å„ªå…ˆ)
                    result.unshift({ type: 'added', value: text2[j - 1] });
                    j--;
                } else if (i > 0) {
                    // å‰Šé™¤
                    result.unshift({ type: 'removed', value: text1[i - 1] });
                    i--;
                }
            }

            // é€£ç¶šã™ã‚‹åŒã˜ã‚¿ã‚¤ãƒ—ã®æ–‡å­—ã‚’ãƒãƒ¼ã‚¸ã—ã€removedç›´å¾Œã®addedã‚’ã¾ã¨ã‚ã‚‹
            const merged = [];
            for (let k = 0; k < result.length; k++) {
                const current = result[k];

                if (merged.length === 0 || merged[merged.length - 1].type !== current.type) {
                    merged.push({ type: current.type, value: current.value });
                } else {
                    merged[merged.length - 1].value += current.value;
                }
            }

            return merged;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã‚’æŒ¿å…¥ã™ã‚‹é–¢æ•°
        function insertCommentIcons(htmlContent, entryId, plainText) {
            const comments = commentsData[entryId] || [];
            if (comments.length === 0) return htmlContent;

            // HTMLã‚’ãƒ‘ãƒ¼ã‚¹ã—ã¦ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã¨ã‚¿ã‚°ãƒãƒ¼ãƒ‰ã‚’åˆ†é›¢
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;

            // ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®offsetä½ç½®ã‚’è¨ˆç®—ã—ãªãŒã‚‰ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¤ã‚³ãƒ³ã‚’æŒ¿å…¥
            let currentOffset = 0;
            const result = [];

            function processNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent;
                    let lastIndex = 0;

                    // ã“ã®ãƒ†ã‚­ã‚¹ãƒˆãƒãƒ¼ãƒ‰å†…ã®ã‚³ãƒ¡ãƒ³ãƒˆä½ç½®ã‚’æ¢ã™
                    comments.forEach((comment, commentIndex) => {
                        if (comment.offset >= currentOffset && comment.offset < currentOffset + text.length) {
                            const relativeOffset = comment.offset - currentOffset;
                            if (relativeOffset > lastIndex) {
                                result.push(escapeHtml(text.substring(lastIndex, relativeOffset)));
                            }
                            const tooltipText = comment.author ? `[${comment.author}] ${comment.comment}` : comment.comment;
                            result.push(`<span class="comment-icon" data-comment-index="${commentIndex}" title="${escapeHtml(tooltipText)}">ğŸ’¬</span>`);
                            lastIndex = relativeOffset;
                        }
                    });

                    if (lastIndex < text.length) {
                        result.push(escapeHtml(text.substring(lastIndex)));
                    }
                    currentOffset += text.length;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    result.push(`<${node.tagName.toLowerCase()}${getAttributesString(node)}>`);
                    Array.from(node.childNodes).forEach(child => processNode(child));
                    result.push(`</${node.tagName.toLowerCase()}>`);
                }
            }

            function getAttributesString(node) {
                let attrs = '';
                Array.from(node.attributes).forEach(attr => {
                    attrs += ` ${attr.name}="${attr.value}"`;
                });
                return attrs;
            }

            Array.from(tempDiv.childNodes).forEach(node => processNode(node));
            return result.join('');
        }

        // ãƒ†ã‚­ã‚¹ãƒˆé¸æŠæ™‚ã®å‡¦ç†
        let addCommentBtn = null;
        function handleTextSelection(e, entryId, editableDisplay) {
            // æ—¢å­˜ã®ãƒœã‚¿ãƒ³ã‚’å‰Šé™¤
            if (addCommentBtn) {
                addCommentBtn.remove();
                addCommentBtn = null;
            }

            const selection = window.getSelection();
            const selectedText = selection.toString();

            if (selectedText.trim().length > 0) {
                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();

                // ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                addCommentBtn = document.createElement('button');
                addCommentBtn.className = 'add-comment-btn';
                addCommentBtn.textContent = 'ğŸ’¬ ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ';
                addCommentBtn.style.top = `${rect.bottom + window.scrollY + 5}px`;
                addCommentBtn.style.left = `${rect.left + window.scrollX}px`;

                addCommentBtn.onclick = function() {
                    // é¸æŠç¯„å›²ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
                    const plainText = editableDisplay.innerText;
                    const selectionStart = getTextOffset(editableDisplay, range.startContainer, range.startOffset);
                    const selectionEnd = getTextOffset(editableDisplay, range.endContainer, range.endOffset);

                    showAddCommentDialog(entryId, selectionStart, selectionEnd - selectionStart, selectedText);
                    addCommentBtn.remove();
                    addCommentBtn = null;
                    selection.removeAllRanges();
                };

                document.body.appendChild(addCommentBtn);
            }
        }

        // DOMãƒãƒ¼ãƒ‰ã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆoffsetã‚’è¨ˆç®—
        function getTextOffset(container, targetNode, targetOffset) {
            let offset = 0;
            let found = false;

            function traverse(node) {
                if (found) return;

                if (node === targetNode) {
                    offset += targetOffset;
                    found = true;
                    return;
                }

                if (node.nodeType === Node.TEXT_NODE) {
                    offset += node.textContent.length;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // comment-iconã¯ã‚¹ã‚­ãƒƒãƒ—
                    if (!node.classList.contains('comment-icon')) {
                        Array.from(node.childNodes).forEach(child => traverse(child));
                    }
                }
            }

            Array.from(container.childNodes).forEach(child => traverse(child));
            return offset;
        }

        // ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’è¡¨ç¤º
        function showAddCommentDialog(entryId, offset, length, selectedText) {
            const overlay = document.createElement('div');
            overlay.className = 'comment-dialog-overlay';

            const dialog = document.createElement('div');
            dialog.className = 'comment-dialog';

            const authorOptions = commentAuthors.map(author =>
                `<option value="${escapeHtml(author)}">${escapeHtml(author)}</option>`
            ).join('');

            dialog.innerHTML = `
                <h3>ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ </h3>
                <p><strong>é¸æŠãƒ†ã‚­ã‚¹ãƒˆ:</strong> "${escapeHtml(selectedText)}"</p>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä½œæˆè€…:</label>
                    <select id="commentAuthor" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 14px;">
                        ${authorOptions}
                    </select>
                </div>
                <textarea id="commentInput" placeholder="ã‚³ãƒ¡ãƒ³ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
                <div class="comment-dialog-buttons">
                    <button class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    <button class="save-btn">ä¿å­˜</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            const commentInput = document.getElementById('commentInput');
            const commentAuthor = document.getElementById('commentAuthor');
            commentInput.focus();

            dialog.querySelector('.cancel-btn').onclick = function() {
                overlay.remove();
                dialog.remove();
            };

            dialog.querySelector('.save-btn').onclick = function() {
                const comment = commentInput.value.trim();
                const author = commentAuthor.value;
                if (comment) {
                    // ã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 
                    if (!commentsData[entryId]) {
                        commentsData[entryId] = [];
                    }
                    commentsData[entryId].push({ offset, length, comment, author });

                    // ã‚³ãƒ¡ãƒ³ãƒˆã‚’offseté †ã«ã‚½ãƒ¼ãƒˆ
                    commentsData[entryId].sort((a, b) => a.offset - b.offset);

                    // ä¿å­˜
                    saveComments();

                    // å†ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                    renderEntries();
                }
                overlay.remove();
                dialog.remove();
            };

            overlay.onclick = function() {
                overlay.remove();
                dialog.remove();
            };
        }

        // ã‚³ãƒ¡ãƒ³ãƒˆè¡¨ç¤º/ç·¨é›†ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
        function showCommentDialog(entryId, commentIndex) {
            const comments = commentsData[entryId] || [];
            if (commentIndex >= comments.length) return;

            const commentData = comments[commentIndex];
            const overlay = document.createElement('div');
            overlay.className = 'comment-dialog-overlay';

            const dialog = document.createElement('div');
            dialog.className = 'comment-dialog';

            const authorOptions = commentAuthors.map(author => {
                const selected = author === commentData.author ? 'selected' : '';
                return `<option value="${escapeHtml(author)}" ${selected}>${escapeHtml(author)}</option>`;
            }).join('');

            dialog.innerHTML = `
                <h3>ã‚³ãƒ¡ãƒ³ãƒˆ</h3>
                <div style="margin-bottom: 10px;">
                    <label style="display: block; margin-bottom: 5px; font-weight: bold;">ä½œæˆè€…:</label>
                    <select id="commentEditAuthor" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 3px; font-size: 14px;">
                        ${authorOptions}
                    </select>
                </div>
                <textarea id="commentEditInput">${escapeHtml(commentData.comment)}</textarea>
                <div class="comment-dialog-buttons">
                    <button class="delete-btn">å‰Šé™¤</button>
                    <button class="cancel-btn">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    <button class="save-btn">æ›´æ–°</button>
                </div>
            `;

            document.body.appendChild(overlay);
            document.body.appendChild(dialog);

            const commentInput = document.getElementById('commentEditInput');
            const commentAuthor = document.getElementById('commentEditAuthor');
            commentInput.focus();

            dialog.querySelector('.delete-btn').onclick = function() {
                if (confirm('ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤ã—ã¾ã™ã‹?')) {
                    commentsData[entryId].splice(commentIndex, 1);
                    if (commentsData[entryId].length === 0) {
                        delete commentsData[entryId];
                    }
                    saveComments();
                    renderEntries();
                    overlay.remove();
                    dialog.remove();
                }
            };

            dialog.querySelector('.cancel-btn').onclick = function() {
                overlay.remove();
                dialog.remove();
            };

            dialog.querySelector('.save-btn').onclick = function() {
                const newComment = commentInput.value.trim();
                const newAuthor = commentAuthor.value;
                if (newComment) {
                    commentsData[entryId][commentIndex].comment = newComment;
                    commentsData[entryId][commentIndex].author = newAuthor;
                    saveComments();
                    renderEntries();
                }
                overlay.remove();
                dialog.remove();
            };

            overlay.onclick = function() {
                overlay.remove();
                dialog.remove();
            };
        }

        function handleTextChange(index, newValue) {
            csvData[index].text_ja = newValue;
            csvData[index].modified = (newValue !== originalData[index].text_ja);

            const textarea = document.querySelector(`textarea[data-index="${index}"]`);
            if (csvData[index].modified) {
                textarea.classList.add('modified');
            } else {
                textarea.classList.remove('modified');
            }

            updateStats();
        }

        function updateStats() {
            totalEntriesSpan.textContent = csvData.length;
            const modifiedCount = csvData.filter(entry => entry.modified).length;
            modifiedEntriesSpan.textContent = modifiedCount;
        }

        async function exportCSV() {
            let csvContent = 'id,kind,text_en,text_ja\n';

            csvData.forEach(entry => {
                const row = [
                    entry.id,
                    escapeCSVField(entry.kind),
                    escapeCSVField(entry.text_en),
                    escapeCSVField(entry.text_ja)
                ];
                csvContent += row.join(',') + '\n';
            });

            try {
                // ã‚µãƒ¼ãƒãƒ¼ã«CSVã‚’ä¿å­˜
                const response = await fetch('/api/save-csv', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        originalPath: currentFileName,
                        csvContent: csvContent
                    })
                });

                const result = await response.json();

                if (result.success) {
                    alert(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒä¿å­˜ã•ã‚Œã¾ã—ãŸ:\n${result.filename}\n\nä¿å­˜å…ˆ: data/${result.path}`);
                } else {
                    throw new Error(result.error || 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
            } catch (error) {
                console.error('ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
                alert(`ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`);
            }
        }

        function escapeCSVField(field) {
            const fieldStr = String(field);
            if (fieldStr.includes(',') || fieldStr.includes('"') || fieldStr.includes('\n')) {
                return '"' + fieldStr.replace(/"/g, '""') + '"';
            }
            return fieldStr;
        }
    </script>
</body>
</html>
